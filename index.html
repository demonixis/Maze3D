<html lang="fr">
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <title>Demonixis.Net Labs - Maze 3D WebGL</title>
    <meta name="description" content="Demonixis\' Labs : JavaScript & WebGL experiments - Labyrinth 3D avec Three.js" />
    <meta name="author" content="Yannick Comte" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <link href='http://fonts.googleapis.com/css?family=Lobster' rel='stylesheet' type='text/css' />
    <link href='http://fonts.googleapis.com/css?family=Overlock' rel='stylesheet' type='text/css' />
    <link rel="stylesheet" media="screen" href="assets/css/style.css" />
    <!--[if lt IE 9]>
    <script src="//html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
</head>
<body>
    <img style="display:none" src="assets/images/preview-laby.png" alt="sharing image" />
    <div id="main" role="main">
        <div id="canvasContainer">
          <div id="joypad">
              <div class="top">
                  <a href="javascript:void(0);" class="joykey" id="keyup"><img src="assets/images/pad/kbup.png" /></a>
              </div>
              <div class="bottom">
                  <a href="javascript:void(0);" class="joykey" id="keyleft"><img src="assets/images/pad/kbleft.png" /></a>
                  <a href="javascript:void(0);" class="joykey" id="keydown"><img src="assets/images/pad/kbdown.png" /></a>
                  <a href="javascript:void(0);" class="joykey" id="keyright"><img src="assets/images/pad/kbright.png" /></a>
              </div>
          </div>
      </div>
      <h4 class="center legend">
        <img class="logo" src="assets/images/webgl-logo.png" alt="webgl" /> WebGL en action avec <a href="https://github.com/mrdoob/three.js/">Three.js</a>
      </h4>
    </div>


<audio id="bumpSound">
    <source src="assets/sound/bat.mp3" />
    <source src="assets/sound/bat.ogg" />
    </audio>
    <script src="assets/js/Three.js"></script>
    <script src="assets/js/Stats.js"></script>
    <script src="assets/js/Demonixis.Input.js"></script>
    <script src="assets/js/Demonixis.Minimap.js"></script>
    <script>   
        (function() {

            var width = window.innerWidth * 0.995;
            var height = window.innerHeight * 0.995;
            var canvasContainer = document.getElementById("canvasContainer");
            canvasContainer.setAttribute("class", "");
            canvasContainer.style.border = "0";
            document.getElementById("main").style.padding = "0";

            var input;
            var running = true;
            
            var miniMap;
            var nextLevel = 2;
            var levelCount = 5;
            
            var cameraSpeed = { 
                translate: 5, 
                rotate: 0.025 
            };
            
            var cameraPositionOrigin = {
                x: 0, 
                y: 0, 
                z: 0,
                mapX: 0,
                mapY: 0,
                mapZ: 0
            }

            var origin = { x: 0, y: 0, z: 0 };

            var renderer;
            var camera;
            var scene;
            var stats;

            var textures = new Array(4);
            var textLoaded = false;

            var map = new Array();

            function initialize ()
            {
                renderer = new THREE.WebGLRenderer({antialias: true});
                renderer.setSize(width, height);
                renderer.setClearColorHex(0xEEEEEE, 1.0);
                renderer.clear();

                camera = new THREE.PerspectiveCamera(45, width / height, 1, 10000);
                camera.position.y = 50;

                scene = new THREE.Scene();

                stats = new Stats();
                stats.domElement.style.position = "absolute";
                stats.domElement.style.bottom = "0px";

                loadTextures();
                
                textureRepeat(textures[0], {x:256, y:256});
                textureRepeat(textures[1], {x:256, y:256});
                
                document.getElementById("canvasContainer").appendChild(stats.domElement);
                document.getElementById("canvasContainer").appendChild(renderer.domElement);
                
                input = new Demonixis.Input();
            }
            
            function textureRepeat(texture, size)
            {
                texture.wrapS = THREE.RepeatWrapping;
                texture.wrapT = THREE.RepeatWrapping;
                texture.repeat.x = size.x;
                texture.repeat.y = size.y;
                return texture;
            }

            function loadTextures()
            {
                textures[0] = THREE.ImageUtils.loadTexture("assets/images/textures/grate02.jpg");
                textures[1] = THREE.ImageUtils.loadTexture("assets/images/textures/slab03.jpg");
                textures[2] = THREE.ImageUtils.loadTexture("assets/images/textures/aztec01.jpg");
                textures[3] = THREE.ImageUtils.loadTexture("assets/images/textures/tarmac02.jpg");
                textLoaded = true;
            }

            function createCubeObject (size, position, colorId)
            {
                var object3D;

                object3D = new THREE.Mesh(new THREE.CubeGeometry(size.x, size.y, size.z), new THREE.MeshBasicMaterial({map: textures[colorId]}));
                object3D.position.set(position.x, position.y, position.z);
                object3D.overdraw = true;

                return object3D;
            }

            function initializeScene () 
            { 
                miniMap = new Demonixis.MiniMap(map[0].length, map.length);
                miniMap.create();
              
                var plateformeSize = {width: (map[0].length * 100), height: (map.length * 100) };
                var sol = new THREE.Mesh(new THREE.CubeGeometry(plateformeSize.width, 5, plateformeSize.height), new THREE.MeshBasicMaterial({map: textures[0]}));
                sol.overdraw = true;
                sol.position.set(-50, 1, -50);
                
                var plafond = new THREE.Mesh(new THREE.CubeGeometry(plateformeSize.width, 5, plateformeSize.height), new THREE.MeshBasicMaterial({map: textures[1]}));
                plafond.position.set(-50, 100, -50);
                plafond.overdraw = true;
                
                scene.add(sol);
                scene.add(plafond);
                
                // Affichage de la map
                for (var y = 0, ly = map.length; y < ly; y++)
                {
                    for (var x = 0, lx = map[x].length; x < lx; x++)
                    {
                        var size = { x: 100, y: 100, z: 100 };

                        var position = {
                            x: -plateformeSize.width / 2 + size.x * x,
                            y: 50,
                            z: -plateformeSize.height / 2 + size.z * y
                        };

                        if (x == 0 && y == 0) 
                        {
                            origin.x = position.x;
                            origin.y = position.y;
                            origin.z = position.z;
                        }

                        if (map[y][x] > 1)
                        {
                            var o3d = createCubeObject(size, position, map[y][x]);
                            scene.add(o3d);
                        }     
                        if (map[y][x] == "D")
                        {
                            camera.position.set(position.x, position.y, position.z);
                            cameraPositionOrigin.x = position.x;
                            cameraPositionOrigin.y = position.y;
                            cameraPositionOrigin.z = position.z;
                            cameraPositionOrigin.mapX = x;
                            cameraPositionOrigin.mapY = y;
                            cameraPositionOrigin.mapZ = 0;
                        }  
                        
                        miniMap.draw(x, y, map[y][x]);
                    }
                }

                // Gestion de l'éclairage
                var ambientLight = new THREE.AmbientLight(0xF6FF4F);
                scene.add(ambientLight);

                var directionalLight = new THREE.DirectionalLight(0xffffff);
                directionalLight.position.set(1, 1, 1).normalize();
                scene.add(directionalLight);
            }


            function update () 
            {
                if (input.keys.up)
                {
                    moveCamera("up");
                }

                if (input.keys.down)
                {
                     moveCamera("down");
                }

                if (input.keys.left)
                {
                    moveCamera("left");
                }

                if (input.keys.right)
                {
                    moveCamera("right");
                }

                // Cas du virtual pad
                var params = {rotation: Math.PI / 2, translation: 100 };
                if (input.joykeys.up) {
                    moveCamera("up", params);
                }

                if (input.joykeys.down) {
                     moveCamera("down", params);
                }

                if (input.joykeys.left) {
                    moveCamera("left", params);
                }

                if (input.joykeys.right) {
                    moveCamera("right", params);
                }

                stats.update();
            }

            function draw ()
            {
                renderer.render(scene, camera);
            }


            function moveCamera(direction, delta)
            {
                var collide = false;
                var position = {x: camera.position.x, z: camera.position.z};
                var rotation = camera.rotation.y;
                var offset = 50;
                
                var customRotation = cameraSpeed;
                if (typeof delta != 'undefined')
                {
                    customRotation = {
                        translate: delta.translation,
                        rotate: delta.rotation
                    }
                }

                switch (direction)
                {
                    case "up":
                        position.x -= Math.sin(-camera.rotation.y) * -customRotation.translate;
                        position.z -= Math.cos(-camera.rotation.y) * customRotation.translate;
                        break;
                    case "down":
                        position.x -= Math.sin(camera.rotation.y) * -customRotation.translate;
                        position.z += Math.cos(camera.rotation.y) * customRotation.translate;
                        break;
                    case "left":
                        rotation += customRotation.rotate;
                        break;
                    case "right":
                        rotation -= customRotation.rotate;
                        break;
                }      
                
                // Position actuelle dans la map
                var tx = Math.abs(Math.floor(((origin.x + (camera.position.x * -1)) / 100)));
                var ty = Math.abs(Math.floor(((origin.z + (camera.position.z * -1)) / 100)));
                
                // Futur position
                var newTx = Math.abs(Math.floor(((origin.x + (position.x * -1) + (offset)) / 100)));
                var newTy = Math.abs(Math.floor(((origin.z + (position.z * -1) + (offset)) / 100)));
                
                // Fix pour ne pas sortir de l'écran
                if (newTx >= map[0].length) { newTx = map[0].length; }
                if (newTx < 0) { newTx = 0; }
                if (newTy >= map.length) { newTy = map.length; }
                if (newTy < 0) { newTy = 0; }
                
                if (map[newTy][newTx] != 1 && !isNaN(map[newTy][newTx])) 
                {
                    collide = true;
                }
                else if (map[newTy][newTx] == "A") // A fixer
                {
                    // La partie est terminée 
                    running = false;
                }

                if (collide == false)    
                {
                    camera.rotation.y = rotation;
                    camera.position.x = position.x;
                    camera.position.z = position.z;
                    
                    miniMap.update({x: newTx, y: newTy});
                }
                else
                {
                    document.getElementById("bumpSound").play();
                }
            }
            
            function endScreen()
            {
              if (nextLevel > levelCount)
              {
                alert("Bravo la partie est finie\n\nMerci d'avoir testé cette démo");
                document.location.href = "http://www.demonixis.net"; 
              }
              else
              {
                // Supprimer tous les enfants
                for (var i = 0, l = scene.children.length; i < l; i++)
                {
                    scene.remove(scene.children[i]);
                }
                loadLevel(++nextLevel);
                running = true;
              }
            }

            function mainLoop (time)
            {
                if (running)
                {
                    update();
                    draw(); 
                    window.requestAnimationFrame(mainLoop, renderer.domElement);
                }
                else
                {
                  endScreen();
                }
            }

            function launch()
            {
                initialize();
                initializeScene();
                mainLoop();
            }
            
            function loadLevel(level)
            {
              var ajax = new XMLHttpRequest();
              ajax.open("GET", "assets/maps/maze3d-" + level + ".json", true);
              ajax.onreadystatechange = function()
              {
                if(ajax.readyState == 4)
                {
                  map = JSON.parse(ajax.responseText);
                  launch();
                }
              }
              ajax.send(null);
            }

            window.onload = function() 
            {  
              var level = 1;
              if (level > 0 || level <= levelCount)
              {
                nextLevel = parseInt(level) + 1;
                loadLevel(level);
              }
            }
        })();
    </script>
    <!--[if lt IE 7 ]>
    <script src="http//ajax.googleapis.com/ajax/libs/chrome-frame/1.0.2/CFInstall.min.js"></script>
    <script>window.attachEvent("onload",function(){CFInstall.check({mode:"overlay"})})</script>
    <![endif]-->
</body>
</html>
